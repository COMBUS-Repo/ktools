/*
* Copyright (c)2015 - 2016 Oasis LMF Limited 
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
*
*   * Redistributions of source code must retain the above copyright
*     notice, this list of conditions and the following disclaimer.
*
*   * Redistributions in binary form must reproduce the above copyright
*     notice, this list of conditions and the following disclaimer in
*     the documentation and/or other materials provided with the
*     distribution.
*
*   * Neither the original author of this software nor the names of its
*     contributors may be used to endorse or promote products derived
*     from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
* COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
* OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
* AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
* THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*/
/*
Author: Ben Matharu  email: ben.matharu@oasislmf.org
*/

#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <set>
#include <vector>
#include <zlib.h>

#if defined(_MSC_VER)
#include "../wingetopt/wingetopt.h"
#else
#include <unistd.h>
#endif

#include "../include/oasis.h"

int damage_bins_ = -1;
int max_damage_bin_found = -1;
bool index_file_ = false;
bool zip_ = false;


int doscan(char* line, int& vulnerability_id, int& intensity_bin_id, int& damage_bin_id, float& probability) {
	return sscanf(line, "%d,%d,%d,%f", &vulnerability_id, &intensity_bin_id, &damage_bin_id, &probability);
}

int doscan(char* line, int& vulnerability_id, int& intensity_bin_id, int& damage_bin_id, double& probability) {
	return sscanf(line, "%d,%d,%d,%lf", &vulnerability_id, &intensity_bin_id, &damage_bin_id, &probability);
}

inline void writezipfiles(FILE ** foutx, FILE ** fouty,
			  std::vector<unsigned char>& rowVZip,
			  std::vector<VulnerabilityRow>& rowV,
			  VulnerabilityIndex& vIdx,
			  const int last_vulnerability_id) {

	rowVZip.clear();
	rowVZip.resize(rowV.size() * sizeof(VulnerabilityRow) + 1024);
	unsigned long len = rowVZip.size();
	compress(&rowVZip[0], &len, (unsigned char *)&rowV[0],
		 rowV.size() * sizeof(VulnerabilityRow));
	fwrite((unsigned char *)&rowVZip[0], len, 1, *foutx);
	vIdx.vulnerability_id = last_vulnerability_id;
	vIdx.size = len;
	vIdx.original_size = rowV.size() * sizeof(VulnerabilityRow);
	fwrite(&vIdx, sizeof(vIdx), 1, *fouty);

}

void doitz() {

	FILE *foutx = fopen("vulnerability.bin.z", "wb");
	FILE *fouty = fopen("vulnerability.idx.z", "wb");

	char line[4096];
	int lineno = 0;
	int last_vulnerability_id = 0;
	int vulnerability_id;
	std::set<int> vulnerabilities;
	VulnerabilityRow vBin;
	VulnerabilityIndex vIdx = {};
	std::vector<VulnerabilityRow> rowV;
	std::vector<unsigned char> rowVZip;

	fwrite(&damage_bins_, sizeof(damage_bins_), 1, foutx);
	vIdx.offset += sizeof(damage_bins_);

	fgets(line, sizeof(line), stdin);   // skip header
	lineno++;
	while (fgets(line, sizeof(line), stdin) != 0) {
		int ret = doscan(line, vulnerability_id, vBin.intensity_bin_id,
				 vBin.damage_bin_id, vBin.probability);
		if (ret != 4) {
			fprintf(stderr, "FATAL: Invalid data in line %d:\n%s\n",
				lineno, line);
			return;
		} else {
			if (damage_bins_ < vBin.damage_bin_id) {
				fprintf(stderr, "WARNING: Maximum damage bin specified %d"
						"is less than that encountered in data %d\n",
						damage_bins_, vBin.damage_bin_id);
			}

			if (vulnerability_id != last_vulnerability_id) {

				if (vulnerabilities.find(vulnerability_id) == vulnerabilities.end()) {
					vulnerabilities.insert(vulnerability_id);
				} else {
					fprintf(stderr,
						"FATAL: Error (%d): vulnerability ID %d has already been converted -"
						" all event data should be contiguous\n",
						lineno, vulnerability_id);
						exit(EXIT_FAILURE);
				}

				if (last_vulnerability_id) {
					writezipfiles(&foutx, &fouty, rowVZip,
						      rowV, vIdx,
						      last_vulnerability_id);
					vIdx.offset += vIdx.size;
					rowV.clear();
				}

				last_vulnerability_id = vulnerability_id;

			}

		}
		rowV.push_back(vBin);
		if (vBin.damage_bin_id > max_damage_bin_found) {
			max_damage_bin_found = vBin.damage_bin_id;
		}

	}		

	writezipfiles(&foutx, &fouty, rowVZip, rowV, vIdx,
		      last_vulnerability_id);
	fclose(foutx);
	fclose(fouty);

}

void doit() {

	Vulnerability v;
	char line[4096];
	int lineno=0;
	int last_vulnerability_id = 0;
	std::set<int> vulnerabilities;
	VulnerabilityRow vBin;
	VulnerabilityIndex vIdx = {};   // vIdx.original_size = 0 always
	int count = 0;

	FILE *foutx = 0;
	FILE *fouty = 0;
	if (index_file_) {
		foutx = fopen("vulnerability.bin", "wb");
		fouty = fopen("vulnerability.idx", "wb");
		fwrite(&damage_bins_, sizeof(damage_bins_), 1, foutx);
		vIdx.offset += sizeof(damage_bins_);
	} else {
		fwrite(&damage_bins_, sizeof(damage_bins_), 1, stdout);
	}

	fgets(line, sizeof(line), stdin);
	lineno++;
	while (fgets(line, sizeof(line), stdin) != 0) {
		int ret = doscan(line, v.vulnerability_id, v.intensity_bin_id, v.damage_bin_id, v.probability);
		if (ret != 4) {
			fprintf(stderr, "FATAL: Invalid data in line %d:\n%s", lineno, line);
			return;
		} else {
			if (damage_bins_ < v.damage_bin_id) {
				fprintf(stderr, "INFO: Error max damage bin specifed %d is less than encountered in data %d\n", damage_bins_, v.damage_bin_id);
			}

			if (index_file_) {

				if (v.vulnerability_id != last_vulnerability_id) {

					if (vulnerabilities.find(v.vulnerability_id) == vulnerabilities.end()) {
						vulnerabilities.insert(v.vulnerability_id);
					} else {
						fprintf(stderr,
							"FATAL: Error (%d): vulnerability ID %d has already been converted -"
							" all event data should be contiguous\n",
							lineno,
							v.vulnerability_id);
						exit(EXIT_FAILURE);
					}

					if (last_vulnerability_id) {
						vIdx.vulnerability_id = last_vulnerability_id;
						vIdx.size = count * sizeof(VulnerabilityRow);
						fwrite(&vIdx, sizeof(vIdx), 1, fouty);
						vIdx.offset += vIdx.size;
					}

					last_vulnerability_id = v.vulnerability_id;
					count = 0;

				}
				vBin.intensity_bin_id = v.intensity_bin_id;
				vBin.damage_bin_id = v.damage_bin_id;
				vBin.probability = v.probability;
				fwrite(&vBin, sizeof(vBin), 1, foutx);
				count++;

			} else {
				fwrite(&v, sizeof(v), 1, stdout);
			}
			
			if (v.damage_bin_id > max_damage_bin_found) max_damage_bin_found = v.damage_bin_id;
		}
		lineno++;
	}

	if (index_file_) {
		vIdx.vulnerability_id = last_vulnerability_id;
		vIdx.size = count * sizeof(VulnerabilityRow);
		fwrite(&vIdx, sizeof(vIdx), 1, fouty);
		fclose(foutx);
		fclose(fouty);
	}

}

void help()
{
	fprintf(stderr,
		"-d maximum damage bin\n"
		"-i use index file (no zip output)\n"
		"-z zip vulnerability data\n"
		"-v version\n"
		"-h help\n");
}

int main(int argc, char *argv[]) {

	int opt;
	bool zip = false;

	while ((opt = getopt(argc, argv, "vhd:iz")) != -1) {
		switch (opt) {
		case 'd':
			damage_bins_ = atoi(optarg);
			break;
		case 'i':
			index_file_ = true;
			break;
		case 'z':
			zip = true;
			break;
		case 'v':
			fprintf(stderr, "%s : version: %s\n", argv[0], VERSION);
			exit(EXIT_FAILURE);
			break;
		case 'h':
			help();
			exit(EXIT_FAILURE);
		default:
			help();
			exit(EXIT_FAILURE);
		}
	}
	if (damage_bins_ == -1) {
		std::cerr << "FATAL: Damage bin paramter not supplied\n";
		help();
		exit(EXIT_FAILURE);
	}


	initstreams("", "");

	if (zip) doitz();
	else doit();

	if (max_damage_bin_found != damage_bins_) {
		fprintf(stderr, "FATAL: Warning: Max damage bin found %d you suppplied %d\n", max_damage_bin_found, damage_bins_);
	}
	return EXIT_SUCCESS;
}
