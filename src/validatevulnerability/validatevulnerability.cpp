#include <cmath>
#include <cstring>
#include <iostream>
#include <set>
#include <stdio.h>
#include <stdlib.h>

#include "../include/oasis.h"

#if defined(_MSC_VER)
#include "../wingetopt/wingetopt.h"
#else
#include <unistd.h>
#endif

namespace validatevulnerability {

  inline bool ProbabilityCheck(float prob) {

    return roundf(prob * 100000) / 100000 != 1.0;

  }

  inline bool ProbabilityError(Vulnerability v, float prob) {

    fprintf(stderr, "Probabilities for vulnerability ID %d", v.vulnerability_id);
    fprintf(stderr, " and intensity bin ID %d", v.intensity_bin_id);
    fprintf(stderr, " do not sum to 1.\n");
    fprintf(stderr, "Probability = %f\n", prob);

    return false;

  }

  inline bool OutOfOrderError(char const * name, int lineno, char * prevLine,
		  	      char * line) {

    fprintf(stderr, "%s IDs in lines %d and %d", name, lineno-1, lineno);
    fprintf(stderr, " not in ascending order:\n");
    fprintf(stderr, "%s\n%s\n", prevLine, line);

    return false;

  }

  void doit() {

    Vulnerability p = {}, q;
    bool dataValid = true;
    std::set<int> damageBins;
    char const * sVulnerability = "Vulnerability";
    char const * sIntensityBin = "Intensity bin";
    float prob = 0.0;
    char prevLine[4096], line[4096];
    sprintf(prevLine, "%d, %d, %d, %f", p.vulnerability_id, p.intensity_bin_id,
	    p.damage_bin_id, p.probability);
    int lineno = 0;
    fgets(line, sizeof(line), stdin);   // Skip header line
    lineno++;

    while(fgets(line, sizeof(line), stdin) != 0) {

      // Check for invalid data
      if(sscanf(line, "%d,%d,%d,%f", &q.vulnerability_id, &q.intensity_bin_id,
		&q.damage_bin_id, &q.probability) != 4) {

	fprintf(stderr, "Invalid data in line %d:\n%s\n", lineno, line);
	dataValid = false;

      }

      // New vulnerability ID
      if(q.vulnerability_id != p.vulnerability_id) {

	// Check total probability for vulnerability-intensity bin combination
	// is 1.0
	if(ProbabilityCheck(prob) && p.vulnerability_id != 0) {

	  dataValid = ProbabilityError(p, prob);

	}

	damageBins.clear();
	prob = 0.0;

	// Check event IDs listed in ascending order
	if(q.vulnerability_id < p.vulnerability_id) {

	  dataValid = OutOfOrderError(sVulnerability, lineno, prevLine, line);

	}

      } else if(q.intensity_bin_id != p.intensity_bin_id) {

	// Check total probability for vulnerability-intensity bin combination
	// is 1.0
	if(ProbabilityCheck(prob)) {

	  dataValid = ProbabilityError(p, prob);

	}

	damageBins.clear();
	prob = 0.0;

	// Check intensity bin IDs listed in ascending order
	if(q.intensity_bin_id < p.intensity_bin_id) {
	
	  dataValid = OutOfOrderError(sIntensityBin, lineno, prevLine, line);

	}

      }

      // Check no duplicate damage bins for each vulnerability-intensity bin
      // combination
      if(damageBins.find(q.damage_bin_id) == damageBins.end()) {

	damageBins.insert(q.damage_bin_id);
	prob += q.probability;

      } else {

	fprintf(stderr, "Duplicate intensity bin for");
	fprintf(stderr, " vulnerability-intensity bin combination");
	fprintf(stderr, "%s\n", line);
	dataValid = false;

      }

      lineno++;
      p = q;
      memcpy(prevLine, line, strlen(line)+1);
      prevLine[strlen(line)-1] = '\0';

    }

    // Check total probability for last vulnerability-intensity bin combination
    // is 1.0
    if(ProbabilityCheck(prob)) {

      dataValid = ProbabilityError(q, prob);

    }

    if(dataValid == true) {

      fprintf(stderr, "All checks pass.\n");

    } else {

      fprintf(stderr, "Some checks have failed. Please edit input file.\n");

    }

  }

}
