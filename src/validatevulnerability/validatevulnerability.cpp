#include <algorithm>
#include <cmath>
#include <cstring>
#include <iostream>
#include <set>
#include <stdio.h>
#include <stdlib.h>
#include <vector>

#include "../include/oasis.h"

#if defined(_MSC_VER)
#include "../wingetopt/wingetopt.h"
#else
#include <unistd.h>
#endif

namespace validatevulnerability {

  inline int CheckIntBinsSum(int intBinsMax) {

    return intBinsMax * (intBinsMax + 1) / 2;

  }

  inline void PrintMissingIntBinIDs(std::set<int> diff, int vul_id,
		  		    bool missingIntBins=true) {

    if(missingIntBins) {
      fprintf(stderr, "Vulnerability ID %d has missing intensity bin IDs: ",
	      vul_id);
    } else {
      fprintf(stderr, "Vulnerability ID %d has unaccounted intensty bin IDs: ",
	      vul_id);
    }

    for(std::set<int>::iterator it=diff.begin(); it!=diff.end(); it++) {
      fprintf(stderr, "%d ", *it);
    }

    fprintf(stderr, "\n");

  }

  void FindSetDifferences(std::set<int> intBins, std::set<int> newIntBins,
		  	  int vul_id) {

    std::set<int> diffS1S2, diffS2S1;
    std::set_difference(intBins.begin(), intBins.end(),
		    	newIntBins.begin(), newIntBins.end(),
			std::inserter(diffS1S2, diffS1S2.begin()));
    std::set_difference(newIntBins.begin(), newIntBins.end(),
		    	intBins.begin(), intBins.end(),
			std::inserter(diffS2S1, diffS2S1.begin()));

    if(!diffS1S2.empty()) {
      PrintMissingIntBinIDs(diffS1S2, vul_id);
    }

    if(!diffS2S1.empty()) {
      PrintMissingIntBinIDs(diffS2S1, vul_id, false);
    }

  }

  inline bool ProbabilityCheck(float prob) {

    return roundf(prob * 100000) / 100000 != 1.0;

  }

  inline bool ProbabilityError(Vulnerability v, float prob) {

    fprintf(stderr, "Probabilities for vulnerability ID %d", v.vulnerability_id);
    fprintf(stderr, " and intensity bin ID %d", v.intensity_bin_id);
    fprintf(stderr, " do not sum to 1.\n");
    fprintf(stderr, "Probability = %f\n", prob);

    return false;

  }

  inline bool OutOfOrderError(char const * name, int lineno, char * prevLine,
		  	      char * line) {

    fprintf(stderr, "%s IDs in lines %d and %d", name, lineno-1, lineno);
    fprintf(stderr, " not in ascending order:\n");
    fprintf(stderr, "%s\n%s\n", prevLine, line);

    return false;

  }

  void doit() {

    Vulnerability p = {}, q;
    bool dataValid = true;
    std::set<int> damageBins;
    int maxDamageBin = 0;
    std::set<int> intBins;
    std::set<int> newIntBins;
    int firstVulID = 0;
    char const * sVulnerability = "Vulnerability";
    char const * sIntensityBin = "Intensity bin";
    float prob = 0.0;
    char prevLine[4096], line[4096];
    sprintf(prevLine, "%d, %d, %d, %f", p.vulnerability_id, p.intensity_bin_id,
	    p.damage_bin_id, p.probability);
    int lineno = 0;
    fgets(line, sizeof(line), stdin);   // Skip header line
    lineno++;

    while(fgets(line, sizeof(line), stdin) != 0) {

      // Check for invalid data
      if(sscanf(line, "%d,%d,%d,%f", &q.vulnerability_id, &q.intensity_bin_id,
		&q.damage_bin_id, &q.probability) != 4) {

	fprintf(stderr, "Invalid data in line %d:\n%s\n", lineno, line);
	dataValid = false;

      }

      // New vulnerability ID
      if(q.vulnerability_id != p.vulnerability_id) {

	// Initiate set of intensity bin IDs for first vulnerability ID
	if(p.vulnerability_id == 0) {

	  intBins.clear();
	  newIntBins.clear();
	  firstVulID = q.vulnerability_id;

	} else if(p.vulnerability_id == firstVulID) {

	  // Build set of intensity bin IDS for first vulnerability ID
	  int intBinsSum = 0;
	  for(std::set<int>::iterator it=intBins.begin(); it!=intBins.end(); it++) {

	    intBinsSum += *it;

	  }

	  // Intensity bins should be contiguous
	  // Fill in missing values from set of intensity bin IDs for first
	  // vulnerability ID using maximum intensity bin value
	  int intBinsSumCheck = CheckIntBinsSum(*(intBins.rbegin()));

	  if(intBinsSum != intBinsSumCheck) {

	    std::set<int> tmpSet;
	    std::vector<int> diff;

	    for(int i=0; i<*(intBins.rbegin()); i++) {

	      tmpSet.insert(i+1);

	    }

	    std::set_difference(tmpSet.begin(), tmpSet.end(),
			        intBins.begin(), intBins.end(),
				std::inserter(diff, diff.begin()));

	    intBins.clear();
	    std::copy(tmpSet.begin(), tmpSet.end(),
		      std::inserter(intBins, intBins.begin()));

	  }

	}

	// Check total probability for vulnerability-intensity bin combination
	// is 1.0
	if(ProbabilityCheck(prob) && p.vulnerability_id != 0) {

	  dataValid = ProbabilityError(p, prob);

	}

	damageBins.clear();
	prob = 0.0;

	// Check event IDs listed in ascending order
	if(q.vulnerability_id < p.vulnerability_id) {

	  dataValid = OutOfOrderError(sVulnerability, lineno, prevLine, line);

	}

	// Check first intensity bin ID is 1 for new vulnerability ID
	if(q.intensity_bin_id != 1) {

	  fprintf(stderr, "First intensity bin index = %d", q.intensity_bin_id);
	  fprintf(stderr, " for vulnerability ID %d.", q.vulnerability_id);
	  fprintf(stderr, " It must be 1.\n");

	  dataValid = false;

	}

      } else if(q.intensity_bin_id != p.intensity_bin_id) {

	// Check total probability for vulnerability-intensity bin combination
	// is 1.0
	if(ProbabilityCheck(prob)) {

	  dataValid = ProbabilityError(p, prob);

	}

	damageBins.clear();
	prob = 0.0;

	// Check intensity bin IDs listed in ascending order
	if(q.intensity_bin_id < p.intensity_bin_id) {
	
	  dataValid = OutOfOrderError(sIntensityBin, lineno, prevLine, line);

	// Else check intensity bin IDs are contiguous
	} else if (q.intensity_bin_id > p.intensity_bin_id+1) {

	  fprintf(stderr, "Non-contiguous intensity bin IDs");
	  fprintf(stderr, " in lines %d and %d", lineno-1, lineno);
	  fprintf(stderr, "%s\n%s\n", prevLine, line);

	  dataValid = false;

	}

      }

      // Fill set of intensity bin IDs for first vulnerability ID
      if(firstVulID == q.vulnerability_id) {

	intBins.insert(q.intensity_bin_id);

      // For any other vulnerability IDs, fill another set of intensity bin IDs
      // for comparison
      } else {

	if(q.vulnerability_id != p.vulnerability_id &&
	   firstVulID != p.vulnerability_id) {

	  FindSetDifferences(intBins, newIntBins, p.vulnerability_id);
	  newIntBins.clear();

	}

	newIntBins.insert(q.intensity_bin_id);

      }

      // Check no duplicate damage bins for each vulnerability-intensity bin
      // combination
      if(damageBins.find(q.damage_bin_id) == damageBins.end()) {

	damageBins.insert(q.damage_bin_id);
	prob += q.probability;

	// Get maximum value of damage_bin_index
	if(q.damage_bin_id > maxDamageBin) {

	  maxDamageBin = q.damage_bin_id;

	}

      } else {

	fprintf(stderr, "Duplicate intensity bin for");
	fprintf(stderr, " vulnerability-intensity bin combination");
	fprintf(stderr, "%s\n", line);
	dataValid = false;

      }

      lineno++;
      p = q;
      memcpy(prevLine, line, strlen(line)+1);
      prevLine[strlen(line)-1] = '\0';

    }

    // For last vulnerability ID, compare intensity bin IDs
    FindSetDifferences(intBins, newIntBins, q.vulnerability_id);

    // Check total probability for last vulnerability-intensity bin combination
    // is 1.0
    if(ProbabilityCheck(prob)) {

      dataValid = ProbabilityError(q, prob);

    }

    if(dataValid == true) {

      fprintf(stderr, "All checks pass.\n");
      fprintf(stderr, "Maximum value of damage_bin_index = %d\n", maxDamageBin);

    } else {

      fprintf(stderr, "Some checks have failed. Please edit input file.\n");

    }

  }

}
